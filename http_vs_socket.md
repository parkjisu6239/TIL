# Socket vs HTTP, 대부분의 서비스가 HTTP를 쓰는 이유

## http

http는 hyper text transfer protocol이다. 클라이언트와 서버가 html, css, js등의 파일을 주고 받기 위한 약속이다. http는 3.0 버전까지 진화했다. 



### http 1.0

http가 처음 나온 1.0 버전에서는 클라이언트-서버간의 통신이 발생한 경우 아래와 같은 과정을 거쳤다.

1. 3 way handshake로 통신 시작
2. 요청
3. 응답
4. 4 wayhandshake로 통신 종료

즉, 매번 모든 요청이 발생할때마 3way, 4way 핸드셰이킹을 하는 오버헤드가 있었다.  요청에 대한 응답이 완료되면 연결은 종료되고, 클라이언트 정보나 연결 정보가 남지 않는다. http의 주요 특징이 비연결, 무상태성이기 때문이다.  그래서 매번 새로 들어온 요청에 대해서 또 연결을 시작하고, 헤더를 분석하는 과정이 있었다. 그리고 먼저 보낸 요청에 대한 응답이 와야 그 다음 요청을 보낼 수 있었다.



### http 1.1

이걸 개선한 http 1.1은 많은 변경점이 있겠지만, 그중 영구히 파이프라인을 연결하도록 업그레이드 되었다. 파이프라인은 클라이언트가 응답을 기다리지 않고 서버에 여러 요청을 보내는 것이다. 하지만 정말 영구히 연결한다기 보다는, 타임아웃의 시간을 늘려 연결 종료까지의 시간을 좀 둔 것이다. 

처음 3way 후에, 연결 종료까지의 시간을 좀 넉넉히 두고, 그 사이에 들어오는 요청, 응답에 대해서는 연결을 다시 하지 않아도 되게 하는 것이다. 하지만 그럼에도 헤더를 분석해야 했다. 

또 http는 어디까지나 요청이 있을때만 응답을 한다. 실시간으로 데이터를 주기적으로 받아오려면 요청을 주기적으로 보내는 polling을 써야 한다.



### polling은 socket의 대안인가?

Polling, long polling 둘다 비슷한 의미다. 위에서 말한 것처럼 통신의 시작하고 끝맺는 사이에 시간 텀을 두고 주기적으로 계속 요청을 보낸다. 사용자가 보기에는 실시간 처럼 보인다. 하지만 이벤트 기반 통신이 아니라 그냥 요청을 반복적으로 보내는 것이기 때문에 서버에 부담이 된다.  서버에 부담이 되는 이유를 정리하자면 다음과 같다.

- http는 stateless 한 프로토콜이다. 각 요청은 완전히 독립적이고 비연결적이다.
- 어떤 http 요청이든 http 프로토콜은 헤더에 700바이트 정도의 데이터를 포함한다.
- 서버에서는 이러한 요청에 대해 세선을 관리하기 위해 쿠키를 사용한다.(다른 방법도 있음 토큰 등). 이때 쿠키 값을 주고 받으면 헤더에 이가 포함되어 프로토콜의 오버헤드가 증가한다.
- http 요청을 개시하는데 쓰이는 tcp handshake는 비용이 꽤나 크다. 주고 받을 데이터가 적은 경우, 실제 데이터보다 핸드셰이킹 하는데 비용이 더 든다.

하지만 이후 http2.0~에서는 위의 단점을 보완하기 위해 헤더압축, 텍스트프로토콜을 바이너리로 대체, 병렬처리 등등 개선 사항들이 있긴하다. 

그리고 위와 같은 단점에도 불구하고 많은 서비스에서 이 방식을 많이 사용한다. polling으로 데이터를 받아와야하는 클라이언트가 그리 많지 않기도 하고, 제한적인 일부 상황에서만 사용하기 때문이다. 그리고 아래에서 소개하겠지만, socket을 쓴다고 서버 부담을 완전히 줄일 수 있는 것은 아니다.





## Websocket

Tcp/ip 스택 위에 구성된 얇은 전송 계층. 웹소켓은 프로토콜이라기 보다는 전송 방식에 더 가깝다고 한다. 일반적으로 프로토콜은 헤더 페이로드 푸터로 이루어지는 정해진 규격을 통해 통신을 하는데, 웹소켓은 페이로드가 내부에서 어떻게 구성되든지 상관이 없기 때문이다. 또, 웹소켓은 websocket frame + payload 인데 header 역할을 하는 프레임이 2~14 바이트로 http에 비해 아주 작다.



### 	WebSocket 통신 방법

실시간 데이터 통신을 위해 사용하는 프로토콜. 웹소켓 역시 처음 통신을 시작할때는 http 를 사용한다. 하지만 한번 연결이 완료된 이후로는 연결을 임의를 종료하기 전까지는 파이프라인이 계속 연결되어 있고. 서버 - 클라이언트가 양방향으로 통신 가능하다. http보다 실시간 통신에 적합하다고 하는 이유는 이벤트 기반의 프로토콜이고, http의 요청/응답 오버헤드가 적기 때문이다.

웹소켓 통신을 시작하면 처음에는 http 요청을 보내는데, 이때 헤더에 아래와 같은 정보를 포함하게 한다.

```text
Connection: Upgrade
Upgrade: websocket
```

이 처럼 통신을 재개하면 `Sec-WebSocket-Key` 을 주고 받아, 통신 대상을 확정한다. 이후로는 굳이 많은 데이터를 포함하는 헤더를 사용하지 않아도, 해쉬값인 키를 통해 통신 대상을 특정할 수 있다.



### websocket은 언제 쓰나 ?

웹소켓은 위와 같은 특성으로 실시간 처리에 많이 사용된다. 하지만 일반적인 웹사이트는 http를 더 많이 사용한다. 만약 100명이 웹사이트에 들어와있다. 그런데 이 웹사이트는 딱히 실시간 처리가 필요없는 사이트라고 하자.(쇼핑몰 같은) 이 사이트가 http로 되어있다고 하면 100명중에 지금 동일한 시점에 데이터를 요청한 건에 대해서만 처리하면 된다. 아마 완전 동일하게 같은 시간에 요청하지는 않을테고 아무리 많아도 10건 정도일 것이다. 그런데 이를 소켓으로 100명이랑 연결하고 있을 필요가 있을까?

그리고 이러한 연결이 실제 현업에서는 다 돈이다. 연결이 많아지면 그만큼 좋은 서버가 있어야하고, 이는 아주 비싸다. 실시간이 정말 필요한 부분에만 쓰는것만도 족하다는 뜻.



## 결론,

- http보다 websocket이 실시간, 양방향 통신에는 좋다.
- 한번 연결된 후에 데이터를 빠르게 주고 받을 수 있다. 이벤트 기반의 통신 방법이다.
- 하지만 대부분의 서비스는 실시간 양방향 통신을 할 필요가 없다!
- 그래서 여전히 http를 사용하는 것이다. 목적에 따라 서로 다른 통신 방법을 선택한 것.



## Reference

- https://ably.com/topic/http2
- https://ably.com/topic/websockets
- https://ably.com/blog/websockets-vs-long-polling
- https://hpbn.co/websocket/